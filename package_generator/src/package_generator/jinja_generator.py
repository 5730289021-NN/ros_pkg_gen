#!/usr/bin/env python
"""
@package package_generator
@file jinja_generator.py
@author Anthony Remazeilles
@brief parse a template file, and generate the related file

Copyright (C) 2019 Tecnalia Research and Innovation
Distributed under the Non-Profit Open Software License 3.0 (NPOSL-3.0).
"""

import jinja2
from package_generator.enhanced_object import EnhancedObject


class JinjaGenerator(EnhancedObject):

    def __init__(self, name="JinjaGenerator"):
        # call super class constructor
        super(JinjaGenerator, self).__init__(name)
        self.xml_parser_ = None
        self.spec_ = None
        self.rendered_ = None

    def configure(self, parser, spec):
        self.xml_parser_ = parser
        self.spec_ = spec
        return True

    def generate_disk_file(self, template_file, output_file=None, force_write=None):

        # creating the dictionnary
        context = dict()
        context["package"] = self.xml_parser_.data_pack_
        context["components"] = self.xml_parser_.data_comp_
        context["active_node"] = self.xml_parser_.active_comp_

        # print "Check components {}".format(context["components"])

        with open(template_file) as file_:
            template = jinja2.Template(file_.read(), trim_blocks=True)

        # Rendered element is a unique string containing all content
        # code generator is generating a list of string instead
        # todo handle exceptions, here or in upper layers.
        str_rendered = template.render(context)

        # convert it in the list of string format:
        self.rendered_ = str_rendered.splitlines()
        if not output_file:
            return True

        if force_write or self.rendered_:
            return self.write_rendered_file(output_file)
        # print "Rendered: \n{}".format(self.rendered_)
        return True

    def generate_open_file(self, template_file, output_file=None, force_write=None):
        # template_file is expected to be a unique string, and not a list of string
        # as is generated by the custom generator

        # creating the dictionnary
        context = dict()
        context["package"] = self.xml_parser_.data_pack_
        context["components"] = self.xml_parser_.data_comp_
        context["active_node"] = self.xml_parser_.active_comp_

        # print "Check components {}".format(context["components"])

        str_template = "\n".join(template_file)
        template = jinja2.Template(str_template, trim_blocks=True)
        # todo handle exceptions, here or in upper layers.
        str_rendered = template.render(context)

        # convert it in the list of string format:
        self.rendered_ = str_rendered.splitlines()

        if not output_file:
            return True

        if force_write or self.rendered_:
            return self.write_rendered_file(output_file)
        # print "Rendered: \n{}".format(self.rendered_)
        return True

    def write_rendered_file(self, filename):

        try:
            with open(filename, 'w') as out_file:
                for item in self.rendered_:
                    out_file.write(item + '\n')
                # todo could this addition be removed?
                # if self.rendered_:
                #    out_file.write('\n')

        except IOError:
            self.log_error("Prb while opening output file {}".format(filename))
            return False
        return True

# todo:
# * Add a field in the template to set the generation mode
# ** to be fair, the best might be adding another file in the template
# ** if file not present, custom is used. Otherwise the generator is read in the file
# * Read the mode, and only apply appropriate generation
# ** add a field to the spec providing the generators used
# ** possible cases: custom, custom+jinja, jinja, jinja + custom
# * Define appropriate context structure
# * Handle error situations
# * update test files
# * update jinja_generator docstrings
# * update documentation
# * handle the template sanity check (if Jinja used)
